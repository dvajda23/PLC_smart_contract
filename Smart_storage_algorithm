//SPDX-License-Identifier: M
pragma solidity ^0.8.x;
contract Sortiranje {
     
   uint[] stanje;
   uint[] racunanje;
   uint[] premikanje;
   uint[] staro_stanje;
   uint stack1;
   uint stack2;
   uint stack3;
   uint stack4;
   uint premiki;
   uint racun;
   uint globalno;
   uint najmanjse;
   uint novo_stanje;
   uint najvecji1;
   uint drugi_najmanjsi;
   uint tretji_najmanjsi;
   uint cetrti_najmanjsi;
   bool senzor_1;
   bool senzor_2;
   bool senzor_3;
   bool senzor_4;
   bool senzor_5;
   bool senzor_6;
   bool senzor_7;
   bool senzor_8;
   bool senzor_9;
   bool senzor_10;
   bool senzor_11; 
   bool senzor_12;
   bool senzor_13;
   bool senzor_14;
   bool senzor_15;
   bool senzor_16;

   /*
   // bool to uint
    uint stack1_1 = senzor_1 ? uint(1) : uint(0);
    uint stack1_2 = senzor_2 ? uint(1) : uint(0);
    uint stack1_3 = senzor_3 ? uint(1) : uint(0);
    uint stack1_4 = senzor_4 ? uint(1) : uint(0);

    stack1 = stack1_1 + stack1_2 + stack1_3 + stack1_4;

    uint stack2_1 = senzor_5 ? uint(1) : uint(0);
    uint stack2_2 = senzor_6 ? uint(1) : uint(0);
    uint stack2_3 = senzor_7 ? uint(1) : uint(0);
    uint stack2_4 = senzor_8 ? uint(1) : uint(0);
    
    stack2 = stack2_1 + stack2_2 + stack2_3 + stack2_4;

    uint stack3_1 = senzor_9 ? uint(1) : uint(0);
    uint stack3_2 = senzor_10 ? uint(1) : uint(0);
    uint stack3_3 = senzor_11 ? uint(1) : uint(0);
    uint stack3_4 = senzor_12 ? uint(1) : uint(0);
    
    stack3 = stack3_1 + stack3_2 + stack3_3 + stack3_4;

    uint stack4_1 = senzor_13 ? uint(1) : uint(0);
    uint stack4_2 = senzor_14 ? uint(1) : uint(0);
    uint stack4_3 = senzor_15 ? uint(1) : uint(0);
    uint stack4_4 = senzor_16 ? uint(1) : uint(0);
    
    stack4 = stack4_1 + stack4_2 + stack4_3 + stack4_4;

    stanje[] = {stack1, stack2, stack3, stack4};

    */


   

   function A_Shranjevanje(uint[] memory _stanje1) public  returns(uint[] memory) {
       stanje = _stanje1;
       staro_stanje = _stanje1;
       return stanje;
   }
   function B_Primerjava(uint[] memory _stanje) public  returns(uint){
  
    uint index = 0;
    uint min = _stanje[0];
    uint temp;
    for (uint _i = 1; _i <= 3; _i++){
        if (_stanje[_i] < min){
        min = _stanje[_i];
        index = _i;

	for(uint i = 1; i <= 3; i++ ){
         for(uint j = i+1; j<=3; j++){
            if(_stanje[i]>_stanje[j]){
               temp = _stanje[i];
               _stanje[i] = _stanje[j];
               _stanje[j] = temp;
               drugi_najmanjsi = stanje[1];
               tretji_najmanjsi = stanje[2];
               cetrti_najmanjsi = stanje[3];
            }
         }
      }
        
        
        }
    }
    najmanjse = index;
    return index; }
    //sedaj poznamo index na katerem se nahaja najmanjše število paketov. če privzamemo da vnašamo št. paketov od leve proti desni, potem vemo na kateri x poziciji je najmanj paketov.
    //imamo optimalno pozicijo za paket!

    function C_Izbira(uint[] memory koordinate) public returns(uint, uint) { //prva koordinata je x, druga pa y, x je vedno [0,1,2,3], lahko vnesemo samo y
      uint najvecji;
      racunanje = koordinate;
      
      uint maxindex = 0; 
      for(uint m = 1; m <= 3; m++){
            if(koordinate[m] > najvecji) {
                najvecji = koordinate[m]; 
       
   } }
         
        
       for (uint n = 1; n <= 3; n++) { 
            if (koordinate[n] > koordinate[maxindex]) {     
                 maxindex = n;  
                 globalno = maxindex;
    } 
}  
            najvecji1 = koordinate[maxindex];
                     
        return (najvecji1, maxindex);


    }
   
 // izberemo kateri paket želimo premakniti. Pri tem so x koordinate [0,1,2,3]. Y koordinate so torej [0,x,0,0], pri čemer je x na tistem mestu, ki ustreza zapisu.
 //torej npr. je lokacija paketa [1,x]. Sedaj moramo odšteti indeksa od shranjevanja in indeksa od izbire, da dobimo koliko premikov paketov potrebujemo, da pridemo do želenega paketa.
   
    function D_Izracun() public returns(uint[] memory)  {
        if (najvecji1 == 4){
            stanje[globalno] = 4;
        }
        if (najvecji1 == 3){
            stanje[globalno] = 3;
        }
        if (najvecji1 == 2){
            stanje[globalno] = 2;

        }
        if (najvecji1 == 1){
            stanje[globalno] = 1;

        }
         return stanje;
    }
    
    function E_Premik() public returns(uint, uint[] memory){ //vrne optimalno stanje skladišča po premikih!
       // stanje = novo_stanje_array;
        novo_stanje = staro_stanje[najmanjse] + (staro_stanje[globalno] - stanje[globalno]); // v tej vrstici je problem
        stanje[najmanjse] = novo_stanje;
        return (novo_stanje, stanje); // Glede na to, da gre v višino največ 4 paketi, potem je situacija problematična le, ko je paket v legah 1-3.
        //y je označen po legah od 1 do 4.

    }
    
    function F_Odlocanje() public {
        if (stanje[drugi_najmanjsi] > 4) {
            stanje[tretji_najmanjsi] = stanje[tretji_najmanjsi] + (stanje[drugi_najmanjsi] - 4);
            stanje[drugi_najmanjsi] = 4;
        }

        if (stanje[tretji_najmanjsi] > 4) {
            stanje[cetrti_najmanjsi] = stanje[cetrti_najmanjsi] + (stanje[tretji_najmanjsi] - 4);
            stanje[cetrti_najmanjsi] = 4;
        }
        if (stanje[cetrti_najmanjsi] > 4) {
           // function Preobremenitev() public returns(string) {
               // return "Preobremenitev skladišča.";
            }
        }



}

    

   
   
